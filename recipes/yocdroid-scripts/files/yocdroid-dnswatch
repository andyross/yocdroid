#!/usr/bin/perl
use warnings;
use strict;
use POSIX ("setsid");

# Daemonize
chdir "/" or die;
exit 0 if fork();
setsid() or die;
open STDIN, "</dev/null";
open STDOUT, ">/dev/null";
open STDERR, ">&STDOUT";
exit 0 if fork();

# Write a pid file
open PID, ">/var/run/yocdroid-dnswatch.pid" or die;
print PID "$$\n";
close PID;

# Get initial configuration
update_tz();
gen_resolv_conf();

# Loop, reading property changes via a pipe (watchprops writes to
# stderr, oddly)
while(1) {
    open PROPS, "-|", "watchprops 2>&1" or die;
    while(<PROPS>) {
	gen_resolv_conf() if /net.change = 'net.dnschange'/;
	update_tz() if /persist.sys.timezone =/;
    }
    close PROPS;
}

sub update_tz() {
    my $tz = `getprop persist.sys.timezone`;
    chomp $tz;
    if(-f "/usr/share/zoneinfo/$tz") {
	system("cp", "/usr/share/zoneinfo/$tz", "/etc/localtime");
	open TZ, ">/etc/timezone";
	print TZ "$tz\n";
	close TZ;
    }
}

sub gen_resolv_conf {
    my @dns;
    # Android 4.2.1 only seems to bother with a hard-coded list of 4
    # servers (i.e. the net.dns[1-4] properties always exist even if
    # empty) check for 8, just because...
    for(my $i=1; $i<=8; $i++) {
	my $svr = `getprop net.dns$i`;
	chomp $svr;
	last if $svr eq "";

	# Stick with IPv4 for now pending me figuring out how IPv6
	# works on Android...
	next if $svr !~ /^(\d+\.){3}\d+$/;

	push @dns, $svr;
    }

    open RC, ">/etc/resolv.conf" or die;
    print RC "# Automatically generated by yocdroid-dnswatch\n";
    print RC "# ", scalar(localtime(time)), "\n";
    foreach my $ip (@dns) {
	print RC "nameserver $ip\n";
    }
    close RC;
}
