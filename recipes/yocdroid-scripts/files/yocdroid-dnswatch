#!/usr/bin/perl
use warnings;
use strict;
use POSIX qw(setsid :sys_wait_h);
use IPC::Open2;

# Yocdroid DNS and time zone updater tool.  Configures the yocdroid
# /etc/resolv.conf, /etc/timezone, and /etc/localtime files at startup
# and monitors the Android property system for updates at runtime.

my $last_tz = "";
my $last_dns = "";

sub daemonize() {
    chdir "/" or die;
    exit 0 if fork();
    setsid() or die;
    open STDIN, "</dev/null";
    open STDOUT, ">/dev/null";
    open STDERR, ">&STDOUT";
    exit 0 if fork();
}

sub update_tz() {
    my $tz = `getprop persist.sys.timezone`;
    chomp $tz;
    if($tz ne $last_tz and -f "/usr/share/zoneinfo/$tz") {
	system("cp", "/usr/share/zoneinfo/$tz", "/etc/localtime");
	open TZ, ">/etc/timezone";
	print TZ "$tz\n";
	close TZ;
	$last_tz = $tz;
    }
}

sub gen_resolv_conf {
    my @dns;
    # Android 4.2.1 only seems to bother with a hard-coded list of 4
    # servers (i.e. the net.dns[1-4] properties always exist even if
    # empty) check for 8, just because...
    for(my $i=1; $i<=8; $i++) {
	my $svr = `getprop net.dns$i`;
	chomp $svr;
	last if $svr eq "";

	# Stick with IPv4 for now pending me figuring out how IPv6
	# works on Android...
	next if $svr !~ /^(\d+\.){3}\d+$/;

	push @dns, $svr;
    }

    my $spec = join(":", @dns);
    if($spec ne $last_dns) {
	open RC, ">/etc/resolv.conf" or die;
	print RC "# Automatically generated by yocdroid-dnswatch\n";
	print RC "# ", scalar(localtime(time)), "\n";
	foreach my $ip (@dns) {
	    print RC "nameserver $ip\n";
	}
	close RC;
	$last_dns = $spec;
    }
}

# FIXME: watchprops spins on the CPU after reading its first property.
# The source code *looks* like it should be waiting on a futex, but it
# pops right out in a tight loop with EAGAIN.  This is what we *want*
# to do: simply parse the output watching for changes.
sub main_loop_BROKEN() {
    while(1) {
	open PROPS, "-|", "watchprops 2>&1" or die;
	while(<PROPS>) {
	    gen_resolv_conf() if /net.change = 'net.dnschange'/;
	    update_tz() if /persist.sys.timezone =/;
	}
	close PROPS;
    }
}

# Instead, we do this hack: run watchprops on a pipe manually to wait
# for only the *first* property set, then kill it (we can't rely on it
# dying with a SIGPIPE because it will spin until a new property
# change).
sub main_loop() {
    open my $devnull, "/dev/null" or die;
    while(1) {
	my $chout;
	my $pid = open2($chout, $devnull, "/system/bin/watchprops 2>&1");
	<$chout>; # Wait for first property change, discard content
	kill 9, $pid;
	close $chout;
	
	# Sleep a bit to prevent spinning on batched property updates.
	# Do it before the reads because of a race: if a bunch of DNS
	# updates happen and we update in the middle, we'll miss the
	# last few.
	sleep(1);

	update_tz();
	gen_resolv_conf();
    }
}

########################################################################

daemonize();

# Set up a signal handler to catch dead children
$SIG{CHLD} = sub { 
    while(waitpid(-1, WNOHANG) > 0) {}
};

# Write a pid file
open PID, ">/var/run/yocdroid-dnswatch.pid" or die;
print PID "$$\n";
close PID;

# Get initial configuration
update_tz();
gen_resolv_conf();

# Loop, reading property changes via a pipe (watchprops writes to
# stderr, oddly).
main_loop();
